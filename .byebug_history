quit
project
c
events_json.first.merge({:color => 'green'})
events_json.first.class
events_json.first
events_json
c
}c
    end
          element.merge!({:color => 'green'})
      else
          element.merge!({:color => 'blue'})
      when "HW"
        element.merge!({:color => 'red'})
      when "FW"
    case event.tasktype
events_json.each {|element|
c
events_json.each.merge!({:color => 'red'})
pp events_json
require 'pp'
print
priny
pp
pp events_json
events_json.class
events_json.merge({:color => 'red'})
events_json
c
(Task.first.endtime+1.day).to_formatted_s(:db)
Task.first.endtime+1.day.to_formatted_s(:db)
Task.first.(endtime+1.day).to_formatted_s(:db)
Task.first.endtime.to_formatted_s(:db)+1.day
Task.first.endtime
Task.first.endtime.to_formatted_s(:db)
Task.first.(endtime+1.day).to_formatted_s(:db)
Task.first.endtime+1.day.to_formatted_s(:db)
Task.first.endtime+1.day
Task.first.endtime
          }}
              :text => event.assignee_from_id_to_name + " - " + event.label
              :end_date => event.endtime.to_formatted_s(:db),
              :start_date => event.starttime.to_formatted_s(:db),
              :id => event.id,
events.map {|event| {
          }}
              :text => event.assignee_from_id_to_name + " - " + event.label
              :end_date => event.endtime.to_formatted_s(:db),
              :start_date => event.starttime.to_formatted_s(:db),
              :id => event.id,
render :json => events.map {|event| {
Task.all
event
json
c
с
:json
json
c
@user
@user.password
c
endtime
timerange
c
с
c
json
c
с
request
request.format
c
request.format
c
json_payload.to_json
json_payload
c
@tasks.to_json
@tasks
c
format.json.call
format.json
pp  format.json
format.json
json
c
@task.valid?
c
errors
@task.valid?
@task
c
Task.new(task_params).valid?
Task.new(task_params)
current_user.tasks.new(task_params).valid?
current_user.tasks.new(task_params)
current_user.tasks.new
current_user.tasks
current_user
@task.class
task_params
@task.valid?
c
timerange_user.include?(timerange)
c
й
с
c
timerange_user.include?(timerange)
c
timerange_user.include?(timerange)
c
timerange_user.include?(timerange)
timerange_user
timerange
c
timerange_user
timerange
c
User.find_by_id(4)
User.find_by_id(4).tasks
User.find_by_id(4).alltasks
User.find_by_id(4).tasks
User.find_by_id(4).alltasks
User.find_by_id(4).tasks
User.find_by_id(4).tasks.all
User.find_by_id(4).tasks
User.find_by_id(4)
c
User.find_by_id(4).tasks
User.find_by_id(4)
User.find_by_id(3)
p User.all
pp User.all
User.all
User.find_by_id(3).tasks
User.find_by_id(4).tasks
User.find_by_id(4).task
User.find_by_id(4).tasks
User.find_by_id(4).tasks.all
User.find_by_id(4).tasks
User.find_by_id(4).tasks.starttime
      return true if timerange_user.include?(timerange)
      timerange_user = task.starttime..task.endtime
User.find_by_id(id).tasks.each do |task|
timerange
timerange = (self.starttime..self.endtime)
User.find_by_id(4)
id
c
task
@task
self.attributes
task_params
task_parms
self.class
self.assignee
self assignee
self.text
p self
pp self
self
c
params
